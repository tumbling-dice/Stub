[Android]クリック時にイベントを発生させるListPreferenceを作成する

<h3>前書き</h3>

<p>相変わらず<a href="https://play.google.com/store/apps/details?id=inujini_.hatate">このような愚にもつかないクソアプリ</a>を作っています。まぁ、楽しいんですが…。それなりには。</p>
<p>設計上<a href="http://developer.android.com/reference/android/preference/Preference.html">Preference</a>を多用するのが一番楽だと判断しましたし、それは恐らく間違ってないんですが、PreferenceそのものがAndroid SDKにおけるBad Partの一つと言っても過言ではないので、ちょっと気を利かせたPreferenceを自作しようとすると結構面倒です。</p>
<p>と言うか、毎回継承しようとするクラスのソースを読まないと動作が理解できないって言うのはフレームワークとして普通に大失敗だと思うんですが、どうなんでしょう。どうなんでしょうって言うか、いい加減にして欲しいんですけどね。</p>

<h3>今回の要件</h3>

<p><a href="http://developer.android.com/reference/android/app/Notification.html">Notification</a>のプロパティとして<a href="http://developer.android.com/reference/android/app/Notification.html#vibrate">vibrate</a>と言うものがあります。読んで字の如く、通知する際に端末を振動させてくれます。そして型を見てもらえばわかる通りlongの配列を渡す必要があります。</p>
<p>具体的にどうやって指定するかと言うと、off,on,off,on...の周期をミリ秒の配列として渡してやればOKです。see alsoとして挙げられている<a href="http://developer.android.com/reference/android/os/Vibrator.html#vibrate(long[], int)">Vibrator#vibrate</a>にそんな説明が書いてあります。</p>

<pre class="brush:java">
Notification n = new Notification();
n.vibrate = new long[]{ 0, 1000, 500, 1000};
// NotificationManagerからNotificationを発行するところは省略
</pre>

<p>このバイブのパターンをListPreferenceでユーザに設定させたい、と言うのが今回の趣旨です。</p>

<h3>ListPreferenceの使い方</h3>

<p>まぁこれぐらいなら普通のListPreferenceでも設定できるんですけどね。とりあえず<a href="http://developer.android.com/reference/android/preference/ListPreference.html">ドキュメント</a>を読んでみましょう。</p>
<p>ListPreference独自のAttrとして<a href="http://developer.android.com/reference/android/preference/ListPreference.html#attr_android:entries">android:entries</a>と<a href="http://developer.android.com/reference/android/preference/ListPreference.html#attr_android:entryValues">android:entryValues</a>があります。これはどちらも<a href="http://developer.android.com/guide/topics/resources/string-resource.html#StringArray">StringArray</a>のリソースIDを指定する必要があります。（<strong>StringArray以外のarrayは渡すことができないので注意</strong>）</p>
<p>実例がないとわかりにくいと思うので他の部分で使っているものを紹介しておきましょう。LEDの色をListPreferenceで設定させています。</p>

<p>arrays.xml</p>
<pre class="brush:xml;highlight:[3,8]">
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string-array name="LightColorList">
        <item>赤</item>
        <item>青</item>
        <item>緑</item>
    </string-array>
    <string-array name="LightColorValues">
        <item>0xffff0000</item>
        <item>0xff0000ff</item>
        <item>0xff00ff00</item>
    </string-array>
</resources>
</pre>

<p>main.xml（抜粋）</p>
<pre class="brush:xml;highlight:[4,5]">
<ListPreference
    android:title="光の色"
    android:summary="@string/summary_light"
    android:entries="@array/LightColorList"
    android:entryValues="@array/LightColorValues"
    android:key="lightColor"
    android:dependency="isLight"/>
</pre>

<p>このように設定すると画面上は赤、青、緑のリスト(LightColorList = android:entries)が表示されますが、実際に設定されている値はそれに対応するカラーコード(LightColorValues = android:entryValues)になっている、と言った按配です。</p>
<p>実際に値を取得する時はこんな感じになります。</p>
<pre class="brush:java">
public static long getLightColor(Context context) {
    SharedPreference pref = PreferenceManager.getDefaultSharedPreferences(context);
    return Long.decode(pref.getString("lightColor", "0xffff0000"));
}
</pre>

<h3>ListPreferenceのダメなところ</h3>

<p>今回の要件から言えばダメなところが二つあります。</p>
<ol>
<li>entryValuesの型がStringArrayで固定されている</li>
<li>リストから選択すると即ダイアログが閉じてしまう</li>
</ol>

<p>特に前者の方は引っかかったことがある人も多いんじゃないでしょうか？<a href="http://developer.android.com/guide/topics/resources/more-resources.html#IntegerArray">IntegerArray</a>や<a href="http://developer.android.com/guide/topics/resources/more-resources.html#TypedArray">TypedArray</a>だって受け取れそうなものなのに、と言いたいところなんですが、ちゃんと考えてみると結構難しいんですよこれが。</p>
<p>なんでこうなっているのかを知るには<a href="http://grepcode.com/file/repository.grepcode.com/java/ext/com.google.android/android/2.0_r1/android/preference/ListPreference.java">ListPreferenceのソース</a>からコンストラクタを見てみるのが一番早いでしょう。</p>

<pre class="brush:java;highlight:[5,6]">
private CharSequence[] mEntries;
private CharSequence[] mEntryValues;

public ListPreference(Context context, AttributeSet attrs) {
    super(context, attrs);
    
    TypedArray a = context.obtainStyledAttributes(attrs,
            com.android.internal.R.styleable.ListPreference, 0, 0);
    mEntries = a.getTextArray(com.android.internal.R.styleable.ListPreference_entries);
    mEntryValues = a.getTextArray(com.android.internal.R.styleable.ListPreference_entryValues);
    a.recycle();
}
</pre>

<p>とまぁ、ここで型を決め打ちしてしまっています。これを対処するとなると何らかの型情報をattrsで渡すしかなさそうですし、mEntries / mEntryValuesの型はObject[]にしないといけません。（<a href="http://www.ne.jp/asahi/hishidama/home/tech/java/array.html#h2_covariant">Javaの配列は共変</a>であり、Object[]にString[]もInteger[]も突っ込めてしまうが絶対にやるべきではない。）</p>
<p>じゃあジェネリクスにすれば、と思うんですが、残念ながらxmlに記述する際に型パラメータを指定することは出来ませんし、結局何かしらの型情報を渡さないと最終的にSharedPreferenceに保存できないです。</p>
<p>どうするにせよ型の問題をどうにかしようとするとListPreferenceを一から作り直さなくてはなりません。そして一から作り直したにしてはあまりにもお粗末なものが出来上がることが目に見えています。ここは涙を飲んで諦めましょう。まぁ、Stringならどうとでもなりますしね。</p>

<p>後者を直すのはさほど難しくないです。と言うか、選択された時点でダイアログを閉じてしまっても問題がないことの方が多いんですが、いちいちパターンを選択する→プレビューで試してみる→パターンを選び直す...と言う作業をユーザにやらせるのはちょっとクールじゃないってだけなので、ぶっちゃけ対処しなくてもいいレベルです。それじゃ話にならないのでちゃんと直しますけども。</p>

<h3>ListPreferenceの実装を調べる</h3>

<p>と言うわけで、もう一度<a href="http://grepcode.com/file/repository.grepcode.com/java/ext/com.google.android/android/2.0_r1/android/preference/ListPreference.java">ListPreferenceのソース</a>に戻ってその辺の制御をしているところを探してみます。ListPrederenceは<a href="http://developer.android.com/reference/android/preference/DialogPreference.html">DialogPreference</a>を継承しているので、恐らくAlertDialog.BuilderにListViewか何かを突っ込んでるのかなとあたりをつけていくと、<a href="http://developer.android.com/reference/android/preference/DialogPreference.html#onPrepareDialogBuilder(android.app.AlertDialog.Builder)">onPrepareDialogBuilder</a>と言うメソッドにぶつかります。</p>

<pre class="brush:java">
@Override
protected void onPrepareDialogBuilder(Builder builder) {
    super.onPrepareDialogBuilder(builder);
    
    if (mEntries == null || mEntryValues == null) {
        throw new IllegalStateException(
                "ListPreference requires an entries array and an entryValues array.");
    }

    mClickedDialogEntryIndex = getValueIndex();
    builder.setSingleChoiceItems(mEntries, mClickedDialogEntryIndex, 
            new DialogInterface.OnClickListener() {
                public void onClick(DialogInterface dialog, int which) {
                    mClickedDialogEntryIndex = which;

                    /*
                     * Clicking on an item simulates the positive button
                     * click, and dismisses the dialog.
                     */
                    ListPreference.this.onClick(dialog, DialogInterface.BUTTON_POSITIVE);
                    dialog.dismiss();
                }
    });
    
    /*
     * The typical interaction for list-based dialogs is to have
     * click-on-an-item dismiss the dialog instead of the user having to
     * press 'Ok'.
     */
    builder.setPositiveButton(null, null);
}

</pre>

<p>ListViewは現れませんでしたが<a href="http://developer.android.com/reference/android/app/AlertDialog.Builder.html#setSingleChoiceItems(java.lang.CharSequence[], int, android.content.DialogInterface.OnClickListener)">AlertDialog.Builder#setSingleChoiceItems</a>を使って制御しているようです。このメソッドで渡しているDialogInterface.OnClickListenerの中身を見ていきましょう。</p>

<pre class="brush:java">
new DialogInterface.OnClickListener() {
    public void onClick(DialogInterface dialog, int which) {
        mClickedDialogEntryIndex = which;

        /*
         * Clicking on an item simulates the positive button
         * click, and dismisses the dialog.
         */
        ListPreference.this.onClick(dialog, DialogInterface.BUTTON_POSITIVE);
        dialog.dismiss();
    }
}

</pre>

<p>mClickedDialogEntryIndexは選択されたリストアイテムのindexです。実際に値を保存する時に使います。（と言うか、それ以外で使われない）</p>
<p>ここのdialog.dismissだけ消せればなぁ、と思うんですが、どうしようもありません。</p>
<p>さて、DialogPreferenceで表示されているdialogがdismissされると<a href="http://developer.android.com/reference/android/preference/DialogPreference.html#onDialogClosed(boolean)">onDialogClosed</a>と言うメソッドに飛びます。わざわざ<a href="http://developer.android.com/reference/android/preference/Preference.html#callChangeListener(java.lang.Object)">callChangeListener</a>を呼び出していることから推測するに、ListPreferenceではここで値を保存しているようですね。</p>

<pre class="brush:java">
@Override
protected void onDialogClosed(boolean positiveResult) {
    super.onDialogClosed(positiveResult);
    
    if (positiveResult && mClickedDialogEntryIndex >= 0 && mEntryValues != null) {
        String value = mEntryValues[mClickedDialogEntryIndex].toString();
        if (callChangeListener(value)) {
            setValue(value);
        }
    }
}
</pre>

<p>このpositiveResultとは何ぞや、って言うのは、<a href="http://grepcode.com/file/repo1.maven.org/maven2/org.robolectric/android-all/4.3_r2-robolectric-0/android/preference/DialogPreference.java">DialogPreferenceのソース</a>を見に行く必要があります。</p>

<pre class="brush:java">
public void onDismiss(DialogInterface dialog) {
    
    getPreferenceManager().unregisterOnActivityDestroyListener(this);
    
    mDialog = null;
    onDialogClosed(mWhichButtonClicked == DialogInterface.BUTTON_POSITIVE);
}

/**
 * Called when the dialog is dismissed and should be used to save data to
 * the {@link SharedPreferences}.
 * 
 * @param positiveResult Whether the positive button was clicked (true), or
 *            the negative button was clicked or the dialog was canceled (false).
 */
protected void onDialogClosed(boolean positiveResult) {
}

</pre>

<p>ListPreferenceがonPrepareDialogBuilderでやっていた内容を思い出しましょう。ListPreference.this.onClick(dialog, DialogInterface.BUTTON_POSITIVE);とbuilder.setPositiveButton(null, null);なんてコードがありました。リストのアイテムを選択した瞬間にDialogPreference#mWhichButtonClickedをDialogInterface.BUTTON_POSITIVEにし、dialog.dismissすることで強制的にpositiveResultをtrueにしているわけです。うーん。アドホック感漂ってますね。</p>

<h3>ListPreferenceを継承して作り直す</h3>
<p>これでListPreferenceが何をやっているのかなんとなくわかりました。次はこれをどう直していくかを考えましょう。</p>
<p>極端な話、onPrepareDialogBuilderで設定しているDialogInterface.OnClickListenerを差し替えてしまう、あるいは、何らかの形で委譲できるようにしてしまえば目的は達成されるように見えます。</p>
<p>単純にDialogInterface.OnClickListenerを受け取れるようにするならこんな感じですね。ただ、onDialogClosedのpositiveResultをtrueで貰えるようにしなきゃいけないので、PositiveButtonはちゃんと作成します。</p>

<pre class="brush:java">
public class EventableListPreference extends ListPreference {

    @Accessors(prefix="_") @Setter private DialogInterface.OnClickListener _onClickListener;

    public EventableListPreference(Context context) {
        super(context);
    }

    public EventableListPreference(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    public EventableListPreference(Context context, AttributeSet attrs, int defStyle) {
        super(context, attrs, defStyle);
    }

    @Override
    protected void onPrepareDialogBuilder(AlertDialog.Builder builder) {

        val entries = super.getEntries();
        val entryValues = super.getEntryValues();

        if (entries == null || entryValues == null) {
            throw new IllegalStateException(
                    "EventableListPreference requires an entries array and an entryValues array.");
        }

        val entryIndex = super.findIndexOfValue(super.getValue());

        builder.setSingleChoiceItems(entries, entryIndex, _onClickListener);

        builder.setPositiveButton("OK", new DialogInterface.OnClickListener() {
            @Override
            public void onClick(DialogInterface dialog, int which) {
                // いるのかな…？
                EventableListPreference.this.onClick(dialog, DialogInterface.BUTTON_POSITIVE);
                dialog.dismiss();
            }
        });
    }
}

</pre>

<p>とは言えこのままだと動きません。ListPreference#mClickedDialogEntryIndexが変わらないので、どれだけ選択しても最終的にはずっと同じ値で保存されます。仕方ないので同じようなプロパティをこっちでも所持し、onDialogClosedをオーバーライドして全く同じことをするようにします。</p>
<p>また、DialogInterface.OnClickListenerを受け取るようにするとやっぱり意味がないので、別のコールバック用インターフェースを作成します。</p>

<pre class="brush:java">
public class EventableListPreference extends ListPreference {

    public interface OnChosenListener {
        public void onChosen(int index, String entry, String entryValue);
    }

    private int _selectedEntryIndex;
    @Accessors(prefix="_") @Setter private OnChosenListener _onChosenListener;
    
    public EventableListPreference(Context context) {
        super(context);
    }

    public EventableListPreference(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    public EventableListPreference(Context context, AttributeSet attrs, int defStyle) {
        super(context, attrs, defStyle);
    }

    @Override
    protected void onPrepareDialogBuilder(AlertDialog.Builder builder) {

        val entries = super.getEntries();
        val entryValues = super.getEntryValues();

        if (entries == null || entryValues == null) {
            throw new IllegalStateException(
                    "EventableListPreference requires an entries array and an entryValues array.");
        }

        builder.setSingleChoiceItems(entries, super.findIndexOfValue(super.getValue())
            , new DialogInterface.OnClickListener() {
                @Override
                public void onClick(DialogInterface dialog, int which) {
                    _selectedEntryIndex = which;
                    if(_onChosenListener != null)
                        _onChosenListener.onChosen(which, super.getEntries()[which], super.getEntryValues()[which]);
                }
        });

        builder.setPositiveButton("OK", new DialogInterface.OnClickListener() {
            @Override
            public void onClick(DialogInterface dialog, int which) {
                EventableListPreference.this.onClick(dialog, DialogInterface.BUTTON_POSITIVE);
                dialog.dismiss();
            }
        });
    }

    @Override
    protected void onDialogClosed(boolean positiveResult) {
        _onChosenListener = null;
        val entryValues = super.getEntryValues();

        if (positiveResult && _selectedEntryIndex >= 0 && entryValues != null) {
            val value = entryValues[_selectedEntryIndex].toString();
            if (callChangeListener(value)) {
                super.setValue(value);
            }
        }
    }
}
</pre>

<p>onPrepareDialogBuilderもonDialogClosedもsuperを呼び出す必要はありません。ListPreferenceの方はそもそも呼び出したくないですし、DialogPreferenceの方はソースを見ればわかる通りどちらも空っぽです。</p>

<h3>まとめ</h3>

<p>後は実例…と思ったんですが、PreferenceActivityからfindPreferenceでEventableListPreferenceを取得し、setOnChosenListenerを呼び出すだけです。その中でentryValueをlongの配列に変換し、<a href="http://developer.android.com/reference/android/os/Vibrator.html">Vibrator</a>をゴニョゴニョすればいけます。</p>
<p>arrays.xmlに記述するバイブのパターンはこんな風にでもしておけばいいでしょう。</p>
<pre class="brush:xml">
<resources>
    <string-array name="VibePatternList">
        <item>１</item>
        <item>２</item>
    </string-array>
    <string-array name="VibePatternValues">
        <item>0,1000,500,1000</item>
        <item>500,1500,1000,1500</item>
    </string-array>
</resources>
</pre>

<h3>参考</h3>
<ul>
<li><a href="http://www.ne.jp/asahi/hishidama/home/tech/java/array.html#h2_covariant">Java配列メモ(Hishidama's Java Array Memo)</a></li>
</ul>